process.noDeprecation = true;
/* Before to start to compile, this will hide the following warning:
DeprecationWarning: loaderUtils.parseQuery() received a non-string value which can be problematic,
see https://github.com/webpack/loader-utils/issues/56
parseQuery() will be replaced with getOptions() in the next major version of loader-utils.
*/

// Dependencies:
const argv = require('yargs').argv;
const webpack = require('webpack');
const path = require('path');
const modules = require('../shared/module');
const resolve = require('../shared/resolve');
const VENDOR_LIBS = require('../shared/vendors');
const PRODUCTION = process.env.NODE_ENV === 'production';
const SERVER = false;
const root = (src) => path.resolve(process.cwd(), src);

/**
 * { Configuration for webpack in the client side (a.k.a. Frontend) }
 * @type {Object}
 */
const config = {
  name: 'Webpack client',
  context: root('src'),
  entry: {
    vendor: VENDOR_LIBS,
  },
  devtool: PRODUCTION ? 'nosources-source-map' : 'cheap-module-eval-source-map',
  // Source maps intend to fix this problem. There are a lot of different options - each with their own advantages and disadvantages.
  // Read more here: https://webpack.js.org/configuration/devtool/
  output: {
    filename: '[name].js',
    path: root('build/public'),
    publicPath: '/',
    sourceMapFilename: 'source-maps/[id].[name].[chunkhash].map',
    chunkFilename: 'chunks/[name].[chunkhash].js',
    hotUpdateChunkFilename: 'hot/[id].[hash].hot-update.js',
  },
  node: {
    fs: 'empty'
    /* This option is used to not worrying when we want some functions like "fs" are shared between the server and the client
       without problems during compilation time,
       for instance, some "webpack" configurations can be shared and this configuration use it to get all paths of our "cwd"
       and then serve them as alias in the project.
       Although there are some reasons and benefits to use it on the client side. */
  },
  module: modules(SERVER, PRODUCTION),
  resolve: resolve,
};

// Configure the publicPath:
if ('env' in argv) {
  let tofile = false
  if ('file' in argv.env && JSON.parse(argv.env.file)) {
    tofile = true;
  }
  if (PRODUCTION) {
    config.output.publicPath = tofile ? '' : '/';
    // When the publicPath is empty the "index.html" file generated by the html-webpack-plugin it is able to work as expected without a server.
  } else {
    config.output.publicPath = 'http://localhost:8080/' // <- devServer.
  }
} else {
  config.output.publicPath = 'http://localhost:8080/' // <- devServer.
}

if (PRODUCTION) {
  config.entry.app = [
    root('src/client/entry.js'),
  ];
} else {
  config.entry.app = [
    'react-hot-loader/patch',
    'webpack-dev-server/client?http://localhost:8080/',
    // For more information visit: https://github.com/glenjamin/webpack-hot-middleware#config
    // https://github.com/gaearon/react-hot-loader/blob/master/docs/Troubleshooting.md#the-following-modules-couldnt-be-hot-updated-they-would-need-a-full-reload
    'webpack/hot/dev-server',
    // Reload when applying HMR fails, see the following url for more details:
    // have in count that if this option is enabled and the port is different of 8080 it will need to be refreshed manually
    // 'webpack/hot/only-dev-server', // Doesn't reload when applying HMR fails.
    root('src/client/entry.js'),
  ];
  config.output.pathinfo = true;
  // useful in development when reading the generated code.
}

module.exports = config;